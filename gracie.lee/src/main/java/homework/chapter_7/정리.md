# 7장. 고급 매핑

---

## 핵심 개념 3가지

| 개념 | 설명 |
|------|------|
| **상속 관계 매핑** | 객체 상속 → 테이블 설계 전략 선택 (다형성 조회 가능: 부모 타입으로 자식 모두 조회) |
| **@MappedSuperclass** | 공통 속성만 상속, 테이블 매핑 X |
| **복합 키와 식별 관계** | 부모 PK를 자식이 PK+FK로 사용 |

---

## 1. 상속 관계 매핑

객체의 상속 구조를 테이블로 매핑하는 3가지 전략

```
        Item (추상)
       / |  \
  Album Book Movie
```

### 전략 1: 조인 전략 (JOINED)

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
    private String artist;
}
```

**테이블 구조:**
```
ITEM  (ID, NAME, PRICE, DTYPE)          ← 부모 테이블
ALBUM (ID(PK,FK), ARTIST)               ← ID = ITEM.ID 참조 (PK이자 FK)
BOOK  (ID(PK,FK), AUTHOR, ISBN)
MOVIE (ID(PK,FK), DIRECTOR, ACTOR)

-- SAMPLE DATA
ITEM  | ID | NAME         | PRICE | DTYPE |
      | 1  | "IU 5집"     | 15000 | A     |
      | 2  | "JPA 책"     | 30000 | B     |
      | 3  | "인터스텔라"  | 12000 | M     |

ALBUM | ID | ARTIST       |
      | 1  | "아이유"      |  ← ITEM.ID=1 과 JOIN

BOOK  | ID | AUTHOR       | ISBN      |
      | 2  | "김영한"      | "978-XXX" |  ← ITEM.ID=2 와 JOIN

MOVIE | ID | DIRECTOR     | ACTOR          |
      | 3  | "놀란"        | "매튜맥커너히"  |  ← ITEM.ID=3 과 JOIN

-- 조회 시 JOIN
SELECT i.*, a.* FROM ITEM i JOIN ALBUM a ON i.ID = a.ID
```

| 장점 | 단점 |
|------|------|
| 테이블 정규화 | 조회 시 JOIN 필요 |
| FK 참조 무결성 제약조건 활용 가능 | INSERT 2번 (부모+자식) |
| 저장공간 효율적 | 쿼리 복잡 |

---

### 전략 2: 단일 테이블 전략 (SINGLE_TABLE) — 기본값

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
}
```

**테이블 구조:**
```
ITEM (ID, NAME, PRICE, DTYPE, ARTIST, AUTHOR, ISBN, DIRECTOR, ACTOR)
     ← 모든 컬럼이 한 테이블에! 사용 안 하는 컬럼은 null

-- SAMPLE DATA
ITEM | ID | NAME         | PRICE | DTYPE | ARTIST   | AUTHOR   | ISBN      | DIRECTOR | ACTOR          |
     | 1  | "IU 5집"     | 15000 | A     | "아이유"  | null     | null      | null     | null           |
     | 2  | "JPA 책"     | 30000 | B     | null      | "김영한"  | "978-XXX" | null     | null           |
     | 3  | "인터스텔라"  | 12000 | M     | null      | null     | null      | "놀란"    | "매튜맥커너히"  |
```

| 장점 | 단점 |
|------|------|
| JOIN 없어서 조회 빠름 | 자식 컬럼은 모두 null 허용 |
| 쿼리 단순 | 테이블이 커질 수 있음 |
| 구분 컬럼(DTYPE) 필수 사용 | |

---

### 전략 3: 구현 클래스마다 테이블 (TABLE_PER_CLASS) — 비추천

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item { ... }
```

**테이블 구조:**
```
ALBUM (ID, NAME, PRICE, ARTIST)
BOOK  (ID, NAME, PRICE, AUTHOR, ISBN)
MOVIE (ID, NAME, PRICE, DIRECTOR, ACTOR)
← Item 테이블 없음, 공통 컬럼 중복

-- SAMPLE DATA
ALBUM | ID | NAME         | PRICE | ARTIST       |
      | 1  | "IU 5집"     | 15000 | "아이유"      |

BOOK  | ID | NAME         | PRICE | AUTHOR       | ISBN      |
      | 2  | "JPA 책"     | 30000 | "김영한"      | "978-XXX" |

MOVIE | ID | NAME         | PRICE | DIRECTOR     | ACTOR          |
      | 3  | "인터스텔라"  | 12000 | "놀란"        | "매튜맥커너히"  |
```

| 장점 | 단점 |
|------|------|
| 서브타입 구분 명확 | 부모 타입 조회 시 UNION 필요 |
| not null 가능 | 여러 테이블을 함께 조회할 때 느림 |

---

### 전략 비교 요약

| 전략 | 테이블 수 | 조회 성능 | 실무 추천 |
|------|----------|----------|----------|
| JOINED | 부모 + 자식 N개 | JOIN (보통) | O |
| SINGLE_TABLE | 1개 | 빠름 | O (단순한 경우) |
| TABLE_PER_CLASS | 자식 N개 | UNION (느림) | X |

---

## 2. @MappedSuperclass

상속 관계 매핑이 아님. 공통 속성만 물려받기 위한 용도.

```java
@MappedSuperclass
public abstract class BaseEntity {
    private LocalDateTime createdDate;
    private LocalDateTime lastModifiedDate;
}

@Entity
public class Member extends BaseEntity {
    @Id @GeneratedValue
    private Long id;
    private String name;
    // createdDate, lastModifiedDate 상속받음
}
```

**특징:**
- 테이블과 매핑 X → `em.find(BaseEntity.class)` 불가
- 직접 생성해서 쓸 일 없으므로 **추상 클래스 권장**
- 등록일, 수정일, 등록자 같은 공통 속성에 주로 사용

```
BaseEntity (테이블 없음)
  ├── Member 테이블: ID, NAME, CREATED_DATE, LAST_MODIFIED_DATE
  └── Team 테이블: ID, TEAM_NAME, CREATED_DATE, LAST_MODIFIED_DATE

-- SAMPLE DATA
MEMBER | ID | NAME     | CREATED_DATE        | LAST_MODIFIED_DATE  |
       | 1  | "김철수"  | 2026-01-01 10:00:00 | 2026-02-01 15:30:00 |
       | 2  | "이영희"  | 2026-01-15 09:00:00 | 2026-01-20 11:00:00 |

TEAM   | ID | TEAM_NAME  | CREATED_DATE        | LAST_MODIFIED_DATE  |
       | 1  | "개발팀"    | 2026-01-01 08:00:00 | 2026-02-10 14:00:00 |
       | 2  | "기획팀"    | 2026-01-05 09:00:00 | 2026-01-30 16:00:00 |

← BaseEntity 테이블은 없고, 공통 컬럼이 각 테이블에 그대로 들어감
```

---

## 3. 복합 키와 식별 관계 매핑

### 식별 관계 vs 비식별 관계

| 구분 | 설명 | 자식 테이블에서 부모 PK |
|------|------|----------------------|
| **식별 관계** | 부모 PK를 자식의 PK + FK로 사용 | PK이자 FK |
| **비식별 관계** | 부모 PK를 자식의 FK로만 사용 | FK만 |

> **실무 권장: 비식별 관계 + Long 대리 키**

### @IdClass 사용

```java
// 복합 키 클래스
@EqualsAndHashCode
public class MemberProductId implements Serializable {
    private Long member;   // MemberProduct.member의 필드명과 일치
    private Long product;  // MemberProduct.product의 필드명과 일치
}

@Entity
@IdClass(MemberProductId.class)
public class MemberProduct {
    @Id @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @Id @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;
}
```

### @EmbeddedId 사용

```java
@Embeddable
@EqualsAndHashCode
public class MemberProductId implements Serializable {
    @Column(name = "MEMBER_ID")
    private Long memberId;
    @Column(name = "PRODUCT_ID")
    private Long productId;
}

@Entity
public class MemberProduct {
    @EmbeddedId
    private MemberProductId id;

    @ManyToOne @MapsId("memberId")
    private Member member;

    @ManyToOne @MapsId("productId")
    private Product product;
}
```

### @IdClass vs @EmbeddedId

| 구분 | @IdClass | @EmbeddedId |
|------|----------|-------------|
| 키 접근 | 엔티티 필드에 직접 접근 | `id.memberId`로 접근 |
| JPQL | `WHERE mp.member = :member` | `WHERE mp.id.memberId = :id` |
| 코드 스타일 | DB 중심 | 객체지향 중심 |

---


## 정리

| 개념 | 핵심 |
|------|------|
| 상속 매핑 | JOINED or SINGLE_TABLE 사용 |
| @MappedSuperclass | 공통 속성 상속용, 테이블 매핑 X |
| 식별/비식별 관계 | 비식별 + Long 대리 키 권장 |
| 복합 키 | @IdClass (단순), @EmbeddedId (객체지향) |

### 7장 주요 어노테이션 정리

| 어노테이션 | 필요한 것 | 사용 케이스 |
|-----------|----------|-----------|
| `@Inheritance(JOINED)` | 자식 테이블에 ID **컬럼** | 객체 상속 → 부모+자식 테이블 분리 |
| `@DiscriminatorColumn` | DTYPE **컬럼** | 상속 전략에서 타입 구분 |
| `@JoinColumn` | 해당 **컬럼** | 연관관계 매핑 시 JOIN 컬럼 지정 |
| `@IdClass` / `@EmbeddedId` | **PK 제약조건** | 복합 키 매핑 |
| `@MapsId` | 해당 **컬럼** | 식별 관계(부모 PK = 자식 PK+FK) 표현 |
| `@MappedSuperclass` | 테이블 없음 | 공통 속성(등록일, 수정일) 상속 |


> 생각해볼 점은 `생각.md` 참고
