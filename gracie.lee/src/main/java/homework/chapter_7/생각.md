# 7장 과제 - 생각해볼 점

---

## 1. @MappedSuperclass를 엔티티 상속으로 안 한 이유?

createdAt/updatedAt만 물려주면 되는데 @Inheritance 쓰면 쓸데없는 테이블이 생김

## 2. 왜 JOINED?

SINGLE_TABLE은 자식 컬럼에 NOT NULL을 못 걸어서 탈락 (NormalItem일 때 billing_cycle_days=null)
TABLE_PER_CLASS는 부모 타입 조회 시 UNION이라 느려서 탈락

## 3. 왜 비식별?

복합키는 코드 복잡하고, 같은 상품 2번 주문 못하는 제약이 생김. 대리키(Long PK)가 단순하고 유연함

## 4. @ElementCollection의 위험?

옵션 변경 시 전체 DELETE 후 재INSERT됨. 옵션 2~3개면 괜찮은데 수백 개면 성능 문제

왜 UPDATE가 아니라 DELETE + INSERT인가?

```
-- 값 타입 컬렉션 테이블 (PK가 없음!)
order_item_option_ch7_kt
| order_item_id | option_key | option_value |
| 1             | color      | black        |
| 1             | size       | M            |
```

PK가 없으니까 Hibernate가 "color=black → color=red"로 바꾸고 싶어도
어떤 row를 UPDATE할지 특정할 방법이 없음

```sql
-- 그래서 이렇게 동작:
-- 1. 해당 OrderItem의 옵션 전부 삭제
DELETE FROM order_item_option_ch7_kt WHERE order_item_id = 1

-- 2. 전부 다시 INSERT (변경 안 된 것도 포함)
INSERT INTO order_item_option_ch7_kt VALUES (1, 'color', 'red')  -- 변경된 것
INSERT INTO order_item_option_ch7_kt VALUES (1, 'size', 'M')     -- 안 바뀐 것도 다시
```

반면 엔티티(@Entity)는 자체 PK가 있어서 개별 수정 가능:
```sql
UPDATE order_item_option SET option_value = 'red' WHERE id = 3
```

## 5. 엔티티 분리하면?

개별 옵션 수정 가능해서 성능은 좋은데, 클래스/매핑 코드가 늘어남

```
-- 엔티티 분리 시 테이블 (자체 PK 있음!)
order_item_option
| id | order_item_id | option_key | option_value |
| 3  | 1             | color      | black        |
| 4  | 1             | size       | M            |
```

```sql
-- 옵션 1개 변경: PK로 특정해서 UPDATE 1번이면 끝
UPDATE order_item_option SET option_value = 'red' WHERE id = 3

-- 옵션 1개 삭제: 해당 row만 삭제
DELETE FROM order_item_option WHERE id = 4

-- 옵션 1개 추가: INSERT 1번
INSERT INTO order_item_option VALUES (5, 1, 'giftWrap', 'true')
```

@ElementCollection은 위 작업 전부 "전체 DELETE + 전체 INSERT"로 처리함
