# 8장. 프록시와 연관관계 관리

---

## 핵심 개념 3가지

| 개념 | 설명 |
|------|------|
| **프록시** | 실제 엔티티 대신 가짜 객체를 넣어 지연 로딩 구현 |
| **즉시/지연 로딩** | 연관 엔티티를 언제 DB에서 가져올지 결정 |
| **영속성 전이 & 고아 객체** | 부모 저장/삭제 시 자식도 함께 관리 |

---

## 1. 프록시

### em.find() vs em.getReference()

| 메서드 | 동작 | DB 조회 시점 |
|--------|------|-------------|
| `em.find()` | 실제 엔티티 반환 | 즉시 |
| `em.getReference()` | 프록시 객체 반환 | 실제 사용 시점 |

```java
Member member = em.getReference(Member.class, 1L);
// → 프록시 객체 (DB 조회 안 함)

member.getName();
// → 이 시점에 SELECT 쿼리 실행 (프록시 초기화)
```

### 프록시 구조

```
HibernateProxy (프록시)
  ├── target → null (초기화 전)
  │            → Member 실제 객체 (초기화 후)
  └── getId(), getName() 등 위임
```

### 프록시 특징

1. **처음 사용할 때 한 번만 초기화** (이후 캐싱)
2. 초기화해도 **프록시가 실제 엔티티로 바뀌지 않음** → target을 통해 접근
3. **프록시 타입 비교** → `==` 대신 `instanceof` 사용

```java
// 다른 영속성 컨텍스트에서 각각 조회한 경우
proxy.getClass() == Member.class  // false (프록시는 Member$HibernateProxy$xxx)
proxy instanceof Member           // true  (상속이니까)
```

4. **같은 영속성 컨텍스트 내 동일성 보장**

```java
// 케이스 1: find 먼저 → getReference도 실제 엔티티 반환
Member a = em.find(Member.class, 1L);
Member b = em.getReference(Member.class, 1L);
a == b                          // true (1차 캐시에 있으니 같은 객체)
a.getClass() == b.getClass()    // true (둘 다 실제 Member)

// 케이스 2: getReference 먼저 → find도 프록시 반환
Member a = em.getReference(Member.class, 1L);
Member b = em.find(Member.class, 1L);
a == b                          // true (동일성 보장을 위해 프록시 반환)
a.getClass() == b.getClass()    // true (둘 다 프록시)
```

> 핵심: 같은 영속성 컨텍스트 내에서 같은 PK면 항상 `a == b`가 `true`

4. **준영속 상태에서 초기화 → 예외**

```java
Member member = em.getReference(Member.class, 1L);
em.detach(member);  // 또는 em.close()
member.getName();   // LazyInitializationException!
```

### 프록시 확인 유틸

```java
// 초기화 여부 확인
emf.getPersistenceUnitUtil().isLoaded(entity);

// 강제 초기화
Hibernate.initialize(entity);
```

---

## 2. 즉시 로딩 vs 지연 로딩

### 즉시 로딩 (EAGER)

```java
@ManyToOne(fetch = FetchType.EAGER)
private Team team;
```

```
em.find(Member.class, 1L)
→ SELECT m.*, t.* FROM MEMBER m JOIN TEAM t ON m.TEAM_ID = t.ID
→ Member와 Team을 한 번에 조회
```

### 지연 로딩 (LAZY)

```java
@ManyToOne(fetch = FetchType.LAZY)
private Team team;
```

```
em.find(Member.class, 1L)
→ SELECT * FROM MEMBER WHERE ID = 1
→ team은 프록시 객체

member.getTeam().getName()
→ SELECT * FROM TEAM WHERE ID = ?
→ 이 시점에 실제 조회
```

### 기본값과 실무 권장

| 어노테이션 | 기본 fetch | 실무 권장 |
|-----------|-----------|----------|
| `@ManyToOne` | **EAGER** | LAZY로 변경 |
| `@OneToOne` | **EAGER** | LAZY로 변경 |
| `@OneToMany` | LAZY | 그대로 유지 |
| `@ManyToMany` | LAZY | 그대로 유지 |

> **실무: 모든 연관관계에 지연 로딩 사용!**
> 필요하면 JPQL fetch join으로 한 번에 조회

### N+1 문제

```java
// EAGER 사용 시
List<Member> members = em.createQuery("SELECT m FROM Member m", Member.class)
    .getResultList();
// 1. Member 전체 조회 (1번)
// 2. 각 Member의 Team 조회 (N번) ← N+1 문제!
```

**해결: LAZY + fetch join**
```java
List<Member> members = em.createQuery(
    "SELECT m FROM Member m JOIN FETCH m.team", Member.class)
    .getResultList();
// 한 번의 JOIN 쿼리로 모두 조회
```

---

## 3. 영속성 전이 (CASCADE)

부모 엔티티를 저장/삭제할 때 자식도 함께 처리

### CASCADE 없이

```java
em.persist(parent);
em.persist(child1);  // 일일이 persist 해야 함
em.persist(child2);
```

### CASCADE 사용

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<Child> children = new ArrayList<>();
}
```

```java
parent.getChildren().add(child1);
parent.getChildren().add(child2);
em.persist(parent);
// → child1, child2도 자동 persist!
```

### CASCADE 종류

| 타입 | 동작 |
|------|------|
| `ALL` | 모든 전이 (실무에서 가장 많이 사용) |
| `PERSIST` | 저장 시 전이 |
| `REMOVE` | 삭제 시 전이 |
| `MERGE` | 병합 시 전이 |
| `REFRESH` | 새로고침 시 전이 |
| `DETACH` | 준영속 시 전이 |

> **주의: CASCADE는 연관관계 매핑과 무관!** 편의 기능일 뿐.
> 소유자가 하나일 때만 사용 (Parent만 Child를 관리하는 경우)

---

## 4. 고아 객체 제거 (orphanRemoval)

부모와의 관계가 끊어진 자식을 자동 삭제

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<>();
}
```

```java
parent.getChildren().remove(0);
// → DELETE FROM CHILD WHERE ID = ? 자동 실행
```

**주의:**
- 참조하는 곳이 하나일 때만 사용 (1:N, 1:1)
- 부모를 제거하면 자식도 모두 삭제 (CascadeType.REMOVE처럼 동작)

---

## 5. CASCADE + orphanRemoval 조합

```java
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
private List<Child> children = new ArrayList<>();
```

**효과: 부모가 자식의 생명주기를 완전히 관리**

```java
// 저장
parent.getChildren().add(child);  // child 자동 persist

// 삭제
parent.getChildren().remove(child);  // child 자동 delete

// 부모 삭제 → 자식 전체 삭제
em.remove(parent);  // children 전부 delete
```

> DDD의 Aggregate Root 개념과 유사:
> Parent = Aggregate Root, Child = 하위 엔티티

---

## 정리

| 개념 | 핵심 |
|------|------|
| 프록시 | `getReference()`로 지연 로딩 구현, `instanceof`로 비교 |
| 즉시 로딩 | 사용 금지! N+1 문제 발생 |
| 지연 로딩 | 모든 연관관계에 LAZY 사용 + 필요 시 fetch join |
| CASCADE | 소유자가 하나일 때, 부모와 함께 persist/remove |
| orphanRemoval | 관계 끊기면 자동 삭제, 참조 하나일 때만 |
| ALL + orphanRemoval | 부모가 자식 생명주기 완전 관리 |
