# 8장 과제 - 생각해볼 점

---

## Q1. teamProxy는 언제 프록시이며, 언제 위험한 객체가 되는가?

**프록시가 반환되는 조건**: `@ManyToOne(fetch = LAZY)`로 설정된 연관관계에서 `m.getTeam()` 호출 시

**프록시 초기화가 트리거되는 조건**: `getId()` 외의 실제 필드에 접근할 때 (예: `getName()`)

**위험해지는 시점**: `em.clear()` 후. 프록시는 초기화할 때 영속성 컨텍스트가 필요한데,
clear로 분리(detached)되면 초기화 불가 → `LazyInitializationException`

---

## Q2. em.clear() 이후에도 참조가 유지되는 이유?

`em.clear()`가 지우는 건 영속성 컨텍스트의 관리 정보(1차 캐시, 변경감지 대상 목록)

자바 객체 참조(`teamProxy` 변수)는 JVM 힙 메모리에 있어서 clear와 무관하게 살아있음

detached 상태가 되면: 변경감지 안 됨, 프록시 초기화 안 됨, merge 없이는 영속성 컨텍스트 이용 불가

---

## Q3. 운영 코드에서 가장 안전한 수정 방법?

```java
// 위험한 코드
Team t = m.getTeam();
em.clear();
t.getName(); // LazyInitializationException
```

**방법 1**: clear 전에 필요한 데이터를 미리 꺼내기
```java
Team t = m.getTeam();
String teamName = t.getName(); // clear 전에 프록시 객체 초기화
em.clear();
```

**방법 2**: fetch join으로 한 번에 조회
```java
Member m = em.createQuery(
    "select m from Member m join fetch m.team where m.id = :id", Member.class)
    .setParameter("id", 1L)
    .getSingleResult();
// team이 이미 초기화된 상태 → clear 이후에도 안전
```

---

## Spring @Transactional과 em.close()의 관계

`@Transactional` 메서드가 끝나면 Spring이 자동으로 `tx.commit()` + `em.close()` 해줌

그래서 서비스가 반환한 엔티티는 밖에서 보면 이미 detached 상태

```java
@Transactional
public Member getMember(Long id) {
    return em.find(Member.class, id);  // team = 프록시
}  // ← Spring이 tx.commit() + em.close()

// 컨트롤러 (tx 밖)
Member m = memberService.getMember(1L);
m.getUsername();           // OK (이미 로딩된 필드)
m.getTeam().getName();     // LazyInitializationException
```

실무 해결 패턴:
- **fetch join**: 서비스 안에서 team까지 한 번에 조회 (아래 설명)
- **DTO 변환**: 서비스 안에서 필요한 값만 꺼내서 DTO로 반환 (아래 설명)
- **open-in-view=true**: 영속성 컨텍스트를 뷰까지 유지 (Spring 기본값인데 비추천)

---

## fetch join이란?

SQL 키워드가 아니라 **JPQL 문법**. JPA한테 "이 연관관계를 프록시 말고 진짜로 채워줘"라는 힌트

```
JPQL:  select m from Member m join fetch m.team
                                    ^^^^^^^^^^
                                    JPA한테 "team도 같이 가져와"

SQL:   SELECT m.*, t.* FROM member m INNER JOIN team t ON m.team_id = t.team_id
       → 결국 INNER JOIN으로 변환됨
```

| JPQL | team 상태                             |
|------|-------------------------------------|
| `select m from Member m` | 프록시 (LAZY) → tx 밖에서 접근하면 Exception  |
| `select m from Member m join fetch m.team` | 진짜 데이터 → tx 밖에서도 안전                 |

```java
@Transactional
public Member getMember(Long id) {
    return em.createQuery(
        "select m from Member m join fetch m.team where m.id = :id", Member.class)
        .setParameter("id", id)
        .getSingleResult();  // team이 이미 진짜 데이터로 채워짐
}

// 컨트롤러 (tx 밖)
m.getTeam().getName();  // OK! 프록시가 아니라 이미 데이터가 있음
```

---

## DTO 변환하는 안전한 방법 

엔티티를 그대로 반환하지 말고, **tx 안에서 필요한 값만 꺼내서 새 객체(DTO)로** 반환

```java
// DTO (단순 데이터 운반 객체)
public record MemberDto(Long id, String username, String teamName) {}

@Transactional
public MemberDto getMember(Long id) {
    Member m = em.find(Member.class, id);
    return new MemberDto(
        m.getId(),
        m.getUsername(),
        m.getTeam().getName()  // tx 안에서 프록시 초기화 → String으로 꺼냄
    );
}

// 컨트롤러 (tx 밖)
MemberDto dto = memberService.getMember(1L);
dto.teamName();  // OK! String이라 프록시와 무관
```

| | fetch join | DTO 변환 |
|--|-----------|---------|
| 반환 타입 | 엔티티 (Member) | DTO (MemberDto) |
| 프록시 문제 | 초기화해서 해결 | 값을 꺼내서 해결 |
| 엔티티 수정 가능? | O | X (읽기 전용) |
| 실무 추천 | 간단한 경우 | API 응답용으로 더 안전 |

---

## 왜 DTO가 더 안전한가?

fetch join은 해결한 연관관계만 안전하고, 나머지 LAZY는 여전히 위험:
```java
// fetch join으로 team만 해결
Member m = memberService.getMember(1L);
m.getTeam().getName();       // OK (fetch join 했으니까)
m.getTeam().getMembers();    //  Team 안의 members 리스트는 fetch join 안 했으니까 LazyInitializationException 위험 있음
```
엔티티를 밖에 내보내는 한, 누군가 다른 LAZY 연관관계를 접근할 위험이 항상 남음

DTO는 프록시가 존재할 수 없는 구조:
```java
public record MemberDto(Long id, String username, String teamName) {}

// MemberDto에는 String teamName만 있음
// Team 엔티티 참조 자체가 없으니까 프록시 접근 가능성이 0
MemberDto dto = memberService.getMember(1L);
dto.teamName();    // 그냥 String
// dto.getTeam()   // 이 메서드 자체가 없음 → 터질 수가 없음
```
